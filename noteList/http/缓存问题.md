# 缓存问题
+ 请求数据后得到了一个响应头：Cache-Control: no-cache
他是什么意思呢？
字面上看感觉是没有缓存的意思，但是实际上响应头的no-cache表达的是可以缓存，但是每次都需要去服务器确认缓存资源的新鲜度，而不是不缓存；
所以当我们两次请求的时候，会在发出请求头带上If-Modified-Since: 某个时间，服务器确认新鲜度，如果客户端资源是新鲜资源则返回304,否则返回200并带上新的图片资源。

+ 当Cache-Control: private之后，说明一个问题，响应头没有给到任何缓存策略，这个时候客户端会怎么处理？

现在浏览器会有一个处理方法，当响应头没有任何缓存策略的时候有一套自己的处理机制，即 Expires = 当前时间(Date - Last-Modified) * 10%,简单理解就是响应头的Date时间与Last-Modified的时间差的十分之一作为缓存的过期时间。
按照这个处理流程，如果马上重新加载，则会直接读取本地缓存内容 ，无需向服务器请求。

# 缓存机制的执行过程
+ 客户端向服务器发出请求，请求资源
+ 服务器返回资源，并通过响应头决定缓存策略
+ 客户端根据响应头的策略决定是否缓存资源（这里假设是），并将响应头与资源缓存下来
+ 在客户端再次请求且命中资源的时候，此时客户端去检查上次缓存的缓存策略，根据策略的不同、是否过期等判断是直接读取本地缓存还是与服务器协商缓存

# 强缓存与协商缓存

强缓存离不开两个响应头**Expires**与**Cache-Control**
+ Expires是http1.0的解决方法，与用户本地时间相挂钩；
``Expires: Wed, 11 May 2019 08:11:00 GMT``
+ Cache-Control是http1.1的解决方案，可以设置相对时间
``Cache-Control: max-age=213660000``
Cache-Control: public可以被所有用户缓存，包括终端和CDN等中间代理服务器
Cache-Control: private只能被终端浏览器缓存，不允许中继缓存服务器进行缓存
Cache-Control: no-cache,先缓存本地，但是在命中缓存之后必须与服务器验证缓存的新鲜度才能使用
Cache-Control: no-store，不会产生任何缓存

# 协商缓存
当第一次请求时服务器返回的响应头中没有Cache-Control和Expires或者Cache-Control和Expires过期抑或它的属性设置为no-cache时，那么浏览器第二次请求时就会与服务器进行协商。
协商主要是通过Last-Modified/If-Modified-Since来进行